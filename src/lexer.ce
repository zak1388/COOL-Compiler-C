#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "lexer.h"

enum TokenType TokenTypeOfString(int size, char tokenString[size]) {
    if (size == 0) {
        return ERROR;
    }

    /* Punctuation */
    for (int i = 0; i < TOKEN_COUNT; i++) {
        if (strcasecmp(tokenString, TokenTypeMap[i]) == 0) {
            return i;
        }
    }

    /* Literals */
    bool isInt = true;
    bool isString = tokenString[0] == '"' && tokenString[size] == '"';
    bool isIdentifer = isalpha(tokenString[0]);
    for (int i = 0; i < size; i++) {
        isInt &= isdigit(tokenString[i]);

        isString &= !(tokenString[i] == '\\' && tokenString[i] == '0');

        isIdentifer &= isalnum(tokenString[i]);
    }

    if (isInt) return INTEGER;
    if (isString) return STRING;
    if (isIdentifer) return IDENTIFIER;

    return ERROR;
}

int coolStringLength(struct Token* t) {
    int length = 0;
    bool escaped = false;

    if (t->type != STRING) return -1;

    int cStrLength = strlen(t->data.asString);
    for (int i = 0; i < cStrLength; i++) {
        if (escaped) {
            escaped = false;
            continue;
        } else if (t->data.asString[i] == '\\') {
            escaped = true;
        }
        length++;
    }

    return length - 2; // ignore quotes
}

struct Token* lex_file(char* filename) {
    FILE *f = fopen(filename, "r");

    if (f == NULL) {
        fprintf(stderr, "Could not open file %s\n", filename);
        return NULL;
    }

    struct Token* first;
    struct Token* last;
    bool reached_eof = false;
    while (!reached_eof) {
        char* tokenString = malloc(BUF_SIZE);
        int size = 0;
        bool in_string = false;
        while (fread(tokenString + size, 1, 1, f) != 0 && ++size < BUF_SIZE - 1) {
            if (*(tokenString + size) == '"') in_string ^= true;
            if (isspace(*(tokenString + size) && !in_string)) {
                size--;
                break;
            }
        };
        if (size == 0) {
            reached_eof = true;
            break;
        } else if (size == 1 && isspace(tokenString[0])) {
            // skip over sections of just whitespace
            continue;
        }

        tokenString[size] = '\0';

        struct Token* t = malloc(sizeof(struct Token));
        t->type = TokenTypeOfString(size, tokenString);

        if (t->type == STRING) strncpy(t->data.asString, tokenString, BUF_SIZE);
        else if (t->type == INTEGER) t->data.asInt = atoi(tokenString);

        if (first == NULL) {
            first = last = t;
        } else {
            last->next = t;
            last = last->next;
        }
    }

    return first;
}

int main(int argc, char* argv[argc]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s cool_files...\n", argv[0]);
        return 1;
    }

    struct Token *t;
    for (int i = 1; i < argc; i++) {
        struct Token* lexed = lex_file(argv[i]);

        if (lexed == NULL) {
            fprintf(stderr, "Failed to lex \"%s\"\n", argv[i]);
            return 1;
        }

        if (t == NULL) t = lexed;
        else {
            struct Token* last_token = t;
            while (last_token->next != NULL) {
                last_token = last_token->next;
            }
            last_token->next = lexed;
        }
    }

    return 0;
}
